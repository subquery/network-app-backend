enum Status {
  INDEXING
  READY
  TERMINATED
}

enum WithdrawalStatus {
  ONGOING
  CLAIMED
  CANCELLED
}

enum WithdrawalType {
  UNDELEGATION
  UNSTAKE
  COMMISSION
  MERGE
}

enum ChannelStatus {
  FINALIZED
  OPEN
  TERMINATING
}

enum DisputeType {
  POI
  QUERY
}

enum DisputeState {
  ONGOING
  ACCEPTED
  REJECTED
  CANCELLED
}

type Project @entity {
  id: ID!

  owner: String!
  metadata: String! # IPFS hash
  currentDeployment: String! # IPFS hash
  currentVersion: String! # IPFS hash
  updatedTimestamp: Date!
  createdTimestamp: Date!

  deployments: [Deployment] @derivedFrom(field: "project")

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Deployment @entity {
  id: ID! # deploymentId, IPFS hash to deployment
  version: String! # IPFS hash to version info
  project: Project!
  indexers: [DeploymentIndexer]! @derivedFrom(field: "deployment")
  createdTimestamp: Date!

  plans: [Plan]! @derivedFrom(field: "deployment")

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type DeploymentIndexer @entity {
  id: ID! # indexer address + deployment id
  indexer: Indexer!
  deployment: Deployment!

  blockHeight: BigInt!
  mmrRoot: String
  timestamp: Date
  status: Status!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Era @entity {
  id: ID! # Era id
  startTime: Date! # Block timestamp the Era is started
  endTime: Date # Block timestamp that the successive Era is started
  forceNext: Boolean # True when force save previous Era
  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

# Necessary without https://github.com/subquery/subql/issues/442
type JSONBigInt @jsonField {
  type: String! # Always "bigint",
  value: String! # Hex encoded string
}

type EraValue @jsonField {
  era: Int!
  value: JSONBigInt!
  valueAfter: JSONBigInt!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Indexer @entity {
  id: ID! # Indexers address
  metadata: String! # IPFS cid
  controller: String # Controller address for the indexer
  commission: EraValue!
  totalStake: EraValue!
  capacity: EraValue!
  maxUnstakeAmount: JSONBigInt!

  controllers: [Controller] @derivedFrom(field: "indexer")
  projects: [DeploymentIndexer] @derivedFrom(field: "indexer")
  delegations: [Delegation] @derivedFrom(field: "indexer")
  rewards: [IndexerReward] @derivedFrom(field: "indexer")

  lastRewardedEra: String # hex encoding
  active: Boolean! # @index
  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type IndexerCommissionRate @entity {
  id: ID! # indexer address + era id
  indexer: Indexer!
  era: Era!
  eraIdx: Int!
  commissionRate: Int!
}

type Controller @entity {
  id: ID! # indexer Address + controller Address
  controller: String!
  indexer: Indexer!

  isActive: Boolean! # Controller currently set to this indexer
  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Delegator @entity {
  id: ID! # Address
  totalDelegations: EraValue!
  delegations: [Delegation] @derivedFrom(field: "delegator")
  claimedRewards: [Reward] @derivedFrom(field: "delegator")
  unclaimedRewards: [UnclaimedReward] @derivedFrom(field: "delegator")

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Delegation @entity {
  id: ID! # nominator + indexer addresses
  delegator: Delegator!
  indexer: Indexer!

  amount: EraValue!
  exitEra: Int

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Withdrawl @entity {
  id: ID! # nominator + index
  index: BigInt! # Index of the withdrawl
  delegator: String! @index # nominator address
  indexer: String! # nominator address
  startTime: Date!
  amount: BigInt!
  type: WithdrawalType!

  status: WithdrawalStatus!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Consumer @entity {
  id: ID! # Consumer Address
  users: [User] @derivedFrom(field: "consumer")

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type User @entity {
  id: ID! # User address
  consumer: Consumer!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type PlanTemplate @entity {
  id: ID! # Index, hex encoded
  period: BigInt!
  dailyReqCap: BigInt!
  rateLimit: BigInt!
  metadata: String
  active: Boolean!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Plan @entity {
  id: ID! # Index, hex encoded
  price: BigInt!
  creator: String! @index # Address
  planTemplate: PlanTemplate!
  active: Boolean!

  deployment: Deployment

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type ServiceAgreement @entity {
  id: ID! # contract address
  indexerAddress: String! @index
  consumerAddress: String! @index
  deployment: Deployment!
  planTemplate: PlanTemplate!

  period: BigInt!
  startTime: Date!
  endTime: Date! @index
  lockedAmount: BigInt!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type UnclaimedReward @entity {
  id: ID! # indexer + delegator
  indexerAddress: String!
  delegatorAddress: String! @index
  delegator: Delegator

  amount: BigInt!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Reward @entity {
  id: ID! # indexer + delegator + tx hash
  indexerAddress: String!
  delegatorAddress: String! @index
  delegator: Delegator

  amount: BigInt!
  claimedTime: Date!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

# Expected total reward an indexer will get each epoch
type IndexerReward @entity {
  id: ID! # indexer + era
  indexer: Indexer!

  # era: Era
  eraIdx: String! #TODO: depreciate
  eraId: BigInt!

  amount: BigInt!
  additions: BigInt!
  removals: BigInt!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type EraReward @entity {
  id: ID! # indexer! + delegator! + era! + commission?
  indexer: Indexer!
  delegator: Delegator!
  era: Era!
  eraIdx: Int!

  isIndexer: Boolean!
  isCommission: Boolean!

  amount: BigInt!
  claimed: Boolean!

  createdBlock: Int
  createdTimestamp: Date!
}

type EraRewardClaimed @entity {
  id: ID! # indexer + delegator
  lastClaimedEra: Int!
}

type IndexerStakeSummary @entity {
  id: ID! # indexer address or 0x00 for global
  era: Era!
  eraIdx: Int!
  totalStake: BigInt!
  indexerStake: BigInt!
  delegatorStake: BigInt!
  nextTotalStake: BigInt!
  nextIndexerStake: BigInt!
  nextDelegatorStake: BigInt!
}

type IndexerStake @entity {
  id: ID! # indexer address + era id
  era: Era!
  eraIdx: Int!
  totalStake: BigInt!
  indexerStake: BigInt!
  delegatorStake: BigInt!
}

type Sqtoken @entity {
  id: ID! # token address
  totalSupply: BigInt! # total supply
  circulatingSupply: BigInt! # totalSupply - airdrop locked - staking locked - treasury holdings
  tokenHolders: [TokenHolder] @derivedFrom(field: "token")
}

type TokenHolder @entity {
  id: ID! # holder address
  balance: BigInt!
  token: Sqtoken!
}

type Transfer @entity {
  id: ID! # holder address
  amount: BigInt!
  from: String!
  to: String!
  timestamp: Date!
  blockheight: BigInt!
}

type Offer @entity {
  id: ID! # offerID
  consumer: String! @index
  deployment: Deployment!
  planTemplate: PlanTemplate!
  deposit: BigInt!
  minimumAcceptHeight: BigInt!
  expireDate: Date! @index
  limit: Int! # indexer cap
  accepted: Int! # accepted indexer amount
  reachLimit: Boolean!
  withdrawn: Boolean! # withdraw by cancel event
  withdrawPenalty: BigInt

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type AcceptedOffer @entity {
  id: ID! # offerID:indexer
  indexer: Indexer!
  offer: Offer!
  serviceAgreement: ServiceAgreement!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type TotalLock @entity {
  id: ID! # TotalLock
  totalDelegation: EraValue!
  totalStake: EraValue!

  createdBlock: Int
  lastEvent: String #topicHandler:blockNumber
}

type Exception @entity {
  id: ID! #eventBlock:txhash
  handler: String!
  error: String!
}

type StateChannel @entity {
  id: ID!

  indexer: String! @index
  consumer: String! @index
  agent: String
  status: ChannelStatus!
  deployment: Deployment!
  total: BigInt!
  price: BigInt!
  spent: BigInt!
  isFinal: Boolean!
  expiredAt: Date! @index
  terminatedAt: Date
  terminateByIndexer: Boolean!
  startTime: Date!

  lastEvent: String #topicHandler:blockNumber
}

type Disputes @entity {
  id: ID! #disputeId
  disputeType: DisputeType!
  state: DisputeState!
  isFinalized: Boolean!

  fisherman: String!
  indexer: String!

  slashAmount: BigInt
  returnAmount: BigInt
}
